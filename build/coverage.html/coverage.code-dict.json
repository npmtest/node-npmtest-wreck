{"/home/travis/build/npmtest/node-npmtest-wreck/test.js":"/* istanbul instrument in package npmtest_wreck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wreck/lib.npmtest_wreck.js":"/* istanbul instrument in package npmtest_wreck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_wreck = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_wreck = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-wreck/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-wreck && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_wreck */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_wreck\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_wreck.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_wreck.rollup.js'] =\n            local.assetsDict['/assets.npmtest_wreck.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_wreck.__dirname + '/lib.npmtest_wreck.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-wreck/node_modules/wreck/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Events = require('events');\nconst Url = require('url');\nconst Http = require('http');\nconst Https = require('https');\nconst Stream = require('stream');\nconst Hoek = require('hoek');\nconst Boom = require('boom');\nconst Payload = require('./payload');\nconst Recorder = require('./recorder');\nconst Tap = require('./tap');\n\n\n// Declare internals\n\nconst internals = {\n    jsonRegex: /^application\\/[a-z.+-]*json$/,\n    shallowOptions: ['agent', 'payload', 'downstreamRes', 'beforeRedirect', 'redirected'],\n    emitSymbol: Symbol.for('wreck')\n};\n\nprocess[internals.emitSymbol] = process[internals.emitSymbol] || new Events.EventEmitter();\n\n\n// new instance is exported as module.exports\n\ninternals.Client = function (defaults) {\n\n    this.agents = {\n        https: new Https.Agent({ maxSockets: Infinity }),\n        http: new Http.Agent({ maxSockets: Infinity }),\n        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })\n    };\n\n    this._defaults = defaults || {};\n\n    Events.EventEmitter.call(this);\n\n    // replay request/response events to process[Symbol.for('wreck')]\n    const self = this;\n    const selfEmit = this.emit;\n    this.emit = function () {\n\n        const processEmitter = process[internals.emitSymbol];\n        selfEmit.apply(self, arguments);\n        processEmitter.emit.apply(processEmitter, arguments);\n    };\n};\n\nHoek.inherits(internals.Client, Events.EventEmitter);\n\n\ninternals.Client.prototype.defaults = function (options) {\n\n    options = Hoek.applyToDefaultsWithShallow(options, this._defaults, internals.shallowOptions);\n    return new internals.Client(options);\n};\n\n\ninternals.resolveUrl = function (baseUrl, path) {\n\n    if (!path) {\n        return baseUrl;\n    }\n\n    const parsedPath = Url.parse(path);\n    if (parsedPath.host && parsedPath.protocol) {\n        return Url.format(parsedPath);\n    }\n\n    const parsedBase = Url.parse(baseUrl);\n    parsedBase.pathname = parsedBase.pathname + parsedPath.pathname;\n    parsedBase.pathname = parsedBase.pathname.replace(/[/]{2,}/g, '/');\n    parsedBase.search = parsedPath.search;      // Always use the querystring from the path argument\n\n    return Url.format(parsedBase);\n};\n\n\ninternals.Client.prototype.request = function (method, url, options, callback, _trace) {\n\n    options = Hoek.applyToDefaultsWithShallow(this._defaults, options || {}, internals.shallowOptions);\n\n    Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object',\n        'options.payload must be a string, a Buffer, a Stream, or an Object');\n\n    Hoek.assert((options.agent === undefined || options.agent === null) || (typeof options.rejectUnauthorized !== 'boolean'),\n        'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');\n\n    Hoek.assert(options.beforeRedirect === undefined || options.beforeRedirect === null || typeof options.beforeRedirect === 'function',\n        'options.beforeRedirect must be a function');\n\n    Hoek.assert(options.redirected === undefined || options.redirected === null || typeof options.redirected === 'function',\n        'options.redirected must be a function');\n\n    options.beforeRedirect = options.beforeRedirect || ((redirectMethod, statusCode, location, resHeaders, redirectOptions, next) => next());\n\n    if (options.baseUrl) {\n        url = internals.resolveUrl(options.baseUrl, url);\n        delete options.baseUrl;\n    }\n\n    const uri = Url.parse(url);\n\n    if (options.socketPath) {\n        uri.socketPath = options.socketPath;\n        delete options.socketPath;\n    }\n\n    uri.method = method.toUpperCase();\n    uri.headers = options.headers || {};\n    const hasContentLength = Object.keys(uri.headers).some((key) => {\n\n        return key.toLowerCase() === 'content-length';\n    });\n\n    if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {\n        options.payload = JSON.stringify(options.payload);\n        uri.headers['content-type'] = uri.headers['content-type'] || 'application/json';\n    }\n\n    const payloadSupported = (uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined);\n    if (payloadSupported &&\n        (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) &&\n        (!hasContentLength)) {\n\n        uri.headers = Hoek.clone(uri.headers);\n        uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);\n    }\n\n    let redirects = (options.hasOwnProperty('redirects') ? options.redirects : false);      // Needed to allow 0 as valid value when passed recursively\n\n    _trace = (_trace || []);\n    _trace.push({ method: uri.method, url });\n\n    const client = (uri.protocol === 'https:' ? Https : Http);\n\n    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {\n        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;\n    }\n    else if (options.agent || options.agent === false) {\n        uri.agent = options.agent;\n    }\n    else {\n        uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;\n    }\n\n    if (options.secureProtocol !== undefined) {\n        uri.secureProtocol = options.secureProtocol;\n    }\n\n    this.emit('request', uri, options);\n\n    const start = Date.now();\n    const req = client.request(uri);\n\n    let shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled\n    let timeoutId;\n\n    const onError = (err) => {\n\n        err.trace = _trace;\n        return finishOnce(Boom.badGateway('Client request error', err));\n    };\n    req.once('error', onError);\n\n    const onResponse = (res) => {\n\n        // Pass-through response\n\n        const statusCode = res.statusCode;\n        const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);\n\n        if (redirects === false ||\n            !redirectMethod) {\n\n            return finishOnce(null, res);\n        }\n\n        // Redirection\n\n        res.destroy();\n\n        if (redirects === 0) {\n            return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));\n        }\n\n        let location = res.headers.location;\n        if (!location) {\n            return finishOnce(Boom.badGateway('Received redirection without location', _trace));\n        }\n\n        if (!/^https?:/i.test(location)) {\n            location = Url.resolve(uri.href, location);\n        }\n\n        const redirectOptions = Hoek.cloneWithShallow(options, internals.shallowOptions);\n        redirectOptions.payload = shadow || options.payload;                                    // shadow must be ready at this point if set\n        redirectOptions.redirects = --redirects;\n\n        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, () => {\n\n            const redirectReq = this.request(redirectMethod, location, redirectOptions, finishOnce, _trace);\n\n            if (options.redirected) {\n                options.redirected(statusCode, location, redirectReq);\n            }\n        });\n    };\n\n    // Register handlers\n\n    const finish = (err, res) => {\n\n        if (err) {\n            req.abort();\n        }\n\n        req.removeListener('response', onResponse);\n        req.removeListener('error', onError);\n        req.on('error', Hoek.ignore);\n        clearTimeout(timeoutId);\n        this.emit('response', err, { req, res, start, uri });\n\n        if (callback) {\n            return callback(err, res);\n        }\n    };\n\n    const finishOnce = Hoek.once(finish);\n\n    req.once('response', onResponse);\n\n    if (options.timeout) {\n        timeoutId = setTimeout(() => {\n\n            return finishOnce(Boom.gatewayTimeout('Client request timeout'));\n        }, options.timeout);\n        delete options.timeout;\n    }\n\n    // Custom abort method to detect early aborts\n\n    const _abort = req.abort;\n    let aborted = false;\n    req.abort = () => {\n\n        if (!aborted && !req.res && !req.socket) {\n            process.nextTick(() => {\n\n                // Fake an ECONNRESET error\n\n                const error = new Error('socket hang up');\n                error.code = 'ECONNRESET';\n                finishOnce(error);\n            });\n        }\n\n        aborted = true;\n        return _abort.call(req);\n    };\n\n    // Write payload\n\n    if (payloadSupported) {\n        if (options.payload instanceof Stream) {\n            let stream = options.payload;\n\n            if (redirects) {\n                const collector = new Tap();\n                collector.once('finish', () => {\n\n                    shadow = collector.collect();\n                });\n\n                stream = options.payload.pipe(collector);\n            }\n\n            stream.pipe(req);\n            return req;\n        }\n\n        req.write(options.payload);\n    }\n\n    // Finalize request\n\n    req.end();\n\n    return req;\n};\n\n\ninternals.redirectMethod = function (code, method, options) {\n\n    switch (code) {\n        case 301:\n        case 302:\n            return method;\n\n        case 303:\n            if (options.redirect303) {\n                return 'GET';\n            }\n            break;\n\n        case 307:\n        case 308:\n            return method;\n    }\n\n    return null;\n};\n\n\n// read()\n\ninternals.Client.prototype.read = function (res, options, callback) {\n\n    options = Hoek.applyToDefaultsWithShallow(options || {}, this._defaults, internals.shallowOptions);\n\n    // Set stream timeout\n\n    const clientTimeout = options.timeout;\n    let clientTimeoutId = null;\n\n    // Finish once\n\n    const finish = (err, buffer) => {\n\n        clearTimeout(clientTimeoutId);\n        reader.removeListener('error', onReaderError);\n        reader.removeListener('finish', onReaderFinish);\n        res.removeListener('error', onResError);\n        res.removeListener('close', onResClose);\n        res.on('error', Hoek.ignore);\n\n        if (err ||\n            !options.json) {\n\n            return callback(err, buffer);\n        }\n\n        // Parse JSON\n\n        let result;\n        if (buffer.length === 0) {\n            return callback(null, null);\n        }\n\n        if (options.json === 'force') {\n            result = internals.tryParseBuffer(buffer);\n            return callback(result.err, result.json);\n        }\n\n        // mode is \"smart\" or true\n\n        const contentType = (res.headers && res.headers['content-type']) || '';\n        const mime = contentType.split(';')[0].trim().toLowerCase();\n\n        if (!internals.jsonRegex.test(mime)) {\n            return callback(null, buffer);\n        }\n\n        result = internals.tryParseBuffer(buffer);\n        return callback(result.err, result.json);\n    };\n\n    const finishOnce = Hoek.once(finish);\n\n    if (clientTimeout &&\n        clientTimeout > 0) {\n\n        clientTimeoutId = setTimeout(() => {\n\n            finishOnce(Boom.clientTimeout());\n        }, clientTimeout);\n    }\n\n    // Hander errors\n\n    const onResError = (err) => {\n\n        return finishOnce(Boom.internal('Payload stream error', err));\n    };\n\n    const onResClose = () => {\n\n        return finishOnce(Boom.internal('Payload stream closed prematurely'));\n    };\n\n    res.once('error', onResError);\n    res.once('close', onResClose);\n\n    // Read payload\n\n    const reader = new Recorder({ maxBytes: options.maxBytes });\n\n    const onReaderError = (err) => {\n\n        if (res.destroy) {                          // GZip stream has no destroy() method\n            res.destroy();\n        }\n\n        return finishOnce(err);\n    };\n\n    reader.once('error', onReaderError);\n\n    const onReaderFinish = () => {\n\n        return finishOnce(null, reader.collect());\n    };\n\n    reader.once('finish', onReaderFinish);\n\n    res.pipe(reader);\n};\n\n\n// toReadableStream()\n\ninternals.Client.prototype.toReadableStream = function (payload, encoding) {\n\n    return new Payload(payload, encoding);\n};\n\n\n// parseCacheControl()\n\ninternals.Client.prototype.parseCacheControl = function (field) {\n\n    /*\n        Cache-Control   = 1#cache-directive\n        cache-directive = token [ \"=\" ( token / quoted-string ) ]\n        token           = [^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+\n        quoted-string   = \"(?:[^\"\\\\]|\\\\.)*\"\n    */\n\n    //                             1: directive                                        =   2: token                                              3: quoted-string\n    const regex = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n    const header = {};\n    const error = field.replace(regex, ($0, $1, $2, $3) => {\n\n        const value = $2 || $3;\n        header[$1] = value ? value.toLowerCase() : true;\n        return '';\n    });\n\n    if (header['max-age']) {\n        try {\n            const maxAge = parseInt(header['max-age'], 10);\n            if (isNaN(maxAge)) {\n                return null;\n            }\n\n            header['max-age'] = maxAge;\n        }\n        catch (err) { }\n    }\n\n    return (error ? null : header);\n};\n\n\n// Shortcuts\n\ninternals.Client.prototype.get = function (uri, options, callback) {\n\n    return this._shortcutWrap('GET', uri, options, callback);\n};\n\n\ninternals.Client.prototype.post = function (uri, options, callback) {\n\n    return this._shortcutWrap('POST', uri, options, callback);\n};\n\n\ninternals.Client.prototype.patch = function (uri, options, callback) {\n\n    return this._shortcutWrap('PATCH', uri, options, callback);\n};\n\n\ninternals.Client.prototype.put = function (uri, options, callback) {\n\n    return this._shortcutWrap('PUT', uri, options, callback);\n};\n\n\ninternals.Client.prototype.delete = function (uri, options, callback) {\n\n    return this._shortcutWrap('DELETE', uri, options, callback);\n};\n\n\n// Wrapper so that shortcut can be optimized with required params\n\ninternals.Client.prototype._shortcutWrap = function (method, uri /* [options], callback */) {\n\n    const options = (typeof arguments[2] === 'function' ? {} : arguments[2]);\n    const callback = (typeof arguments[2] === 'function' ? arguments[2] : arguments[3]);\n\n    return this._shortcut(method, uri, options, callback);\n};\n\n\ninternals.Client.prototype._shortcut = function (method, uri, options, callback) {\n\n    return this.request(method, uri, options, (err, res) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        this.read(res, options, (err, payload) => {\n\n            if (!err && res.statusCode >= 400) {\n                return callback(Boom.create(res.statusCode, 'Response Error: ' + res.statusMessage, {\n                    isResponseError: true,\n                    headers: res.headers,\n                    payload\n                }));\n            }\n\n            return callback(err, res, payload);\n        });\n    });\n};\n\n\ninternals.tryParseBuffer = function (buffer) {\n\n    const result = {\n        json: null,\n        err: null\n    };\n    try {\n        const json = JSON.parse(buffer.toString());\n        result.json = json;\n    }\n    catch (err) {\n        result.err = err;\n    }\n    return result;\n};\n\n\nmodule.exports = new internals.Client();\n","/home/travis/build/npmtest/node-npmtest-wreck/node_modules/wreck/lib/payload.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Stream = require('stream');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Payload = function (payload, encoding) {\n\n    Stream.Readable.call(this);\n\n    const data = [].concat(payload || '');\n    let size = 0;\n    for (let i = 0; i < data.length; ++i) {\n        const chunk = data[i];\n        size = size + chunk.length;\n        data[i] = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk);\n    }\n\n    this._data = Buffer.concat(data, size);\n    this._position = 0;\n    this._encoding = encoding || 'utf8';\n};\n\nHoek.inherits(internals.Payload, Stream.Readable);\n\n\ninternals.Payload.prototype._read = function (size) {\n\n    const chunk = this._data.slice(this._position, this._position + size);\n    this.push(chunk, this._encoding);\n    this._position = this._position + chunk.length;\n\n    if (this._position >= this._data.length) {\n        this.push(null);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-wreck/node_modules/wreck/lib/recorder.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Stream = require('stream');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Recorder = function (options) {\n\n    Stream.Writable.call(this);\n\n    this.settings = options;                // No need to clone since called internally with new object\n    this.buffers = [];\n    this.length = 0;\n};\n\nHoek.inherits(internals.Recorder, Stream.Writable);\n\n\ninternals.Recorder.prototype._write = function (chunk, encoding, next) {\n\n    if (this.settings.maxBytes &&\n        this.length + chunk.length > this.settings.maxBytes) {\n\n        return this.emit('error', Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));\n    }\n\n    this.length = this.length + chunk.length;\n    this.buffers.push(chunk);\n    next();\n};\n\n\ninternals.Recorder.prototype.collect = function () {\n\n    const buffer = (this.buffers.length === 0 ? new Buffer(0) : (this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length)));\n    return buffer;\n};\n","/home/travis/build/npmtest/node-npmtest-wreck/node_modules/wreck/lib/tap.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Stream = require('stream');\nconst Payload = require('./payload');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Tap = function () {\n\n    Stream.Transform.call(this);\n    this.buffers = [];\n};\n\nHoek.inherits(internals.Tap, Stream.Transform);\n\n\ninternals.Tap.prototype._transform = function (chunk, encoding, next) {\n\n    this.buffers.push(chunk);\n    next(null, chunk);\n};\n\n\ninternals.Tap.prototype.collect = function () {\n\n    return new Payload(this.buffers);\n};\n"}